<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>gtest on thinkerou</title>
    <link>https://thinkerou.com/tags/gtest/</link>
    <description>Recent content in gtest on thinkerou</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 12 Jul 2015 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://thinkerou.com/tags/gtest/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>使用 gtest 给 DLL 工程编写单元测试</title>
      <link>https://thinkerou.com/post/gtest-dll/</link>
      <pubDate>Sun, 12 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://thinkerou.com/post/gtest-dll/</guid>
      <description>背景说明 任何时候给你的代码增加单元测试（或接口测试）都不晚，对于 C/C++ 使用比较广泛的单元测试框架应该非 googletest 莫属了。
通常在工程代码中，使用 gtest 比较广泛的方式是以 lib 的形式来做单元测试，这种方式使用也比较简单直接，本文就不再赘述。
但是，对于大部分工程代码而言，并不是只有 EXE 文件，通常这些 EXE 文件都会依赖至少一个 DLL 文件，同时这些 DLL 文件并不会导出所有函数或类，而仅导出极少的东西给外部使用。（注：本文仅讨论 gtest 在 windows 上的应用）
那么，问题来了，该如何使用 gtest 对 DLL 里没有导出的函数或类做单元测试呢？
解决方案 做为示例，假设整个 Solution 包含如下三个 project：
 coreTest 工程：一个被 mainTest 工程应用的 DLL 库；
 mainTest 工程：整个 Solution 的 main 入口，调用 coreTest.dll 的 EXE 文件；
 unitTest 工程：将 gtest 包装成 DLL 的工程。
  详细的代码示例及工程属性设置请阅读完整的示例代码。
为了使用 gtest 对 DLL 里没有导出的函数或类进行单元测试，或许会有如下两种方法：
 新建一个 EXE 工程，然后将所有被测文件包含进来，即可编写对应文件的 unittest，使用 gtest 的 lib 方式；</description>
    </item>
    
    <item>
      <title>如何对模板类进行单元测试</title>
      <link>https://thinkerou.com/post/how-test-template-using-gtest/</link>
      <pubDate>Sun, 17 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://thinkerou.com/post/how-test-template-using-gtest/</guid>
      <description>背景介绍 在对 C++ 项目进行单元测试时，基本都在使用 gtest 进行。无论是单元测试，还是接口测试。
具体来说，就是对函数进行单元测试或接口测试，对模块进行集成测试。但是，对于模板类并没有进行测试，而是对其上层调用进行测试。
现在的问题是，对于模板类需不需要进行单元测试或接口测试？被写成模板类，说明这个类是比较通用且很多地方都在使用它，所以我认为还是有必要进行测试的。
如何测试单参数模板类 现有如下一个模板类：
// 不用纠结于细节，只为说明。 template &amp;lt;typename E&amp;gt; class Queue { public: Queue() { } void Enqueue(const E&amp;amp; element) { } E* Dequeue() { } size_t size() const { return (size_t)123; } };  那么使用 gtest 该如何对该类进行测试呢？
第一步：需要构建工厂类，用于创建被测试类： // 主模板类 template &amp;lt;class T&amp;gt; Queue&amp;lt;T&amp;gt;* CreateQueue(); // 全特化版本1 template &amp;lt;&amp;gt; Queue&amp;lt;int&amp;gt;* CreateQueue&amp;lt;int&amp;gt;() { return new Queue &amp;lt; int &amp;gt; ; } // 全特化版本2 template &amp;lt;&amp;gt; Queue&amp;lt;char&amp;gt;* CreateQueue&amp;lt;char&amp;gt;() { return new Queue &amp;lt; char &amp;gt; ; }  第二步，编写测试类： template &amp;lt;class T&amp;gt; class QueueTest : public testing::Test { protected: QueueTest() : queue(CreateQueue&amp;lt;T&amp;gt;()) { } virtual ~QueueTest() { delete queue; } Queue&amp;lt;T&amp;gt;* const queue; };  第三步，定义需要测试的类型列表： typedef ::testing::Types&amp;lt;int, char&amp;gt; Implementations;  第四步，编写测试用例： TYPED_TEST_CASE(QueueTest, Implementations); TYPED_TEST(QueueTest, DefaultConstructor) { EXPECT_EQ(123, this-&amp;gt;queue-&amp;gt;size()); }  第五步，运行用例，查看结果。 特别说明</description>
    </item>
    
  </channel>
</rss>